git
===
Created Friday 18 July 2014

An untracked file is a file that exists in the working tree of a git repository but isn't listed in the index. 

An unstaged is a file that is listed in the index, but the contents of the file in the working tree are different to the contents listed in the index - the sha1 hash of the file in the working tree is different to the sha1 hash for that the same file in the list maintained by the index, usually because the file has been edited since the index was last updated by a checkout, reset or add command.

In both cases, running git add on the file will cause the file to be both staged and tracked and if the index is the committed in that state then the tree referenced by the new commit will contain a file with the same sha1 hash as the previously staged file

whatever file you create are shown in untracked by git, 
use git add to make it tracked, whatever changes you make in tracked files are shown as modified
when you git commit, objects are created index are created for those files 

if you want to not see untracked files put their names in gitignore

for git autocompletion use: source /etc/bash_completion.d/git

changes made to git are visible automatically to netbeans:

git pull origin master: means there is remote named origin, local copy of that master is in origin/master and we have our master branch
we can merge using git merge

HEAD is, normally, a symbolic reference to [the tip of] a branch when we checkout branch. we can point head to another commit( in detached HEAD state ) and create new branch from there.

try to avoid merge, run git rebase before pushing code, even on pull git by default merges code with branch( say master ). use rebase strategy on pull instead of merge
git config --global branch.autosetuprebase always

we can use git reflog to view brief history what we did recently, although viewing it with git lg is more better

diff b/w checkout and reset
checkout moves HEAD to some commit, while reset moves current branch to some commit

always make logical commits so that you can revert them if needed later

diff b/w reset and revert
reset: undo working changes and return to particular commit, commits are removed so shouldn't be done on public branches
revert: working dir should be clean before doing it, used for public commits


git checkout -b newBranch existBranch
create newBranch from existBranch

git checkout bug 
to change to bug branch

git add file
add file to current branch

git status
to show status of current files

git commit -m "first comment"
commit the changes to local

git push
it will push all the branches from local to remote

git push origin bug
push bug branch to remote

git pull 
it will pull all branches from remote to local

git pull origin Branch
it will pull Branch from remote to local

git cherry -v master
changes of current branch only; use origin/master if branch was made off origin/master rather than master

git log master..
changes if current branch only; use origin/master if branch was made off origin/master rather than master

git checkout 0d1d7fc32
to checkout prevous logged commit

git reset --hard 0d1d7fc32
this will destroy local modifications; use git stash before it if you want to keep current changes

git show-branch
to see branches and their commits 

git show --pretty="format:" --name-only bd61ad98
to show the list of files in commit with id bd61ad98.

or use:
git diff-tree --no-commit-id --name-only -r bd61ad98

git branch -a
shows all local and remote branches

git branch -v
shows head of each local branch

git remote -v
show fetch and push origins

adding upstream to branch
git branch --set-upstream-to=origin

script to see git tree:
git config --global alias.lg "log --graph --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)â€” %an%C(reset)%C(bold yellow)%d%C(reset)' --abbrev-commit --date=relative --all"

now use 
git lg to show tree
git lg shows commits acc to time, branches, head are just pointers to those commits

to get file from other branch 
git checkout branchX file2

git pull does a git fetch followed by a git merge. so git fetch is always safe.	
http://stackoverflow.com/questions/292357/what-are-the-differences-between-git-pull-and-git-fetch

git merging selective files:
http://stackoverflow.com/questions/449541/how-do-you-merge-selective-files-with-git-merge

adding files to git:
$ git add .   # add to index only files created/modified and not those deleted
$ git add -u  # add to index only files deleted/modified and not those created
$ git add -A  # do both operation at once, add to index all files

diff b/w two branches
git diff branch_1..branch_2

diff b/w two branches with filenames only
git diff --name-status branch1..branch2

annotated tag in git
git tag -a v1.4 -m 'my version 1.4'

search for tags
git tag -l 'v3.2.7*'

delete branch on origin
 git push --delete origin branch_name

adding remote 
git remote add origin https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY

rules for rebasing b1 on to b2
git pull both the branches involved
git checkout b1
git rebase b2 // it will cut b1 and put it on b2
git checkout b1
git merge b2 // it will move b2 till b1

*** imp links ***
http://stackoverflow.com/questions/4114095/revert-to-a-previous-git-commit
fundamentals of git: http://stackoverflow.com/questions/3329943/git-branch-fork-fetch-merge-rebase-and-clone-what-are-the-differences/9204499#9204499


pre-commit hook to give warning for debug calls in code 

#!/bin/sh
git diff --cached --name-only | while read FILE; do
#.php files
  if  "$FILE" =~ ^.+(php)$ ; then
      RESULT=$(grep "echo\|print_r\|var_dump\|file_put_contents\|debug_backtrace\|debug_print_backtrace" "$FILE")
      if  ! -z $RESULT ; then
        echo -e "\e[1;33m\tWarning, the commit contains a debug function call. Commit was not aborted, however.\e[0m" >&2
        echo -e "\e[1;33m\tFile: $FILE\e[0m" >&2
        echo -e "$RESULT" >&2
      fi

  fi
#.js files
  if  "$FILE" =~ ^.+(js)$ ; then
      RESULT=$(grep "console.log" "$FILE")
      if  ! -z $RESULT ; then
        echo -e "\e[1;33m\tWarning, the commit contains a debug function call. Commit was not aborted, however.\e[0m" >&2
        echo -e "\e[1;33m\tFile: $FILE\e[0m" >&2
        echo -e "$RESULT" >&2
      fi
  fi
#Add new category of file type here if required..
done


phpcs pre-commit hook 

#!/bin/bash
# PHP CodeSniffer pre-commit hook for git
#
# @author Soenke Ruempler <soenke@ruempler.eu>
# @author Sebastian Kaspari <s.kaspari@googlemail.com>
#
# see the README

PHPCS_BIN=/usr/bin/phpcs
PHPCS_CODING_STANDARD=Naukri
PHPCS_IGNORE=
TMP_STAGING=".phpcs_tmp"
DEBUG_MODE=0

if [ "$DEBUG_MODE" -eq "1" ]
    then
    echo "executing phpcs pre-commit hook..."
fi

# parse config
CONFIG_FILE=$(dirname $0)/config
if [ -e $CONFIG_FILE ]; then
    . $CONFIG_FILE
fi

# simple check if code sniffer is set up correctly
if [ ! -x $PHPCS_BIN ]; then
    echo "PHP CodeSniffer bin not found or executable -> $PHPCS_BIN"
    exit 1
fi

# stolen from template file
if git rev-parse --verify HEAD
then
    against=HEAD
else
    # Initial commit: diff against an empty tree object
    against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
fi

# this is the magic:
# retrieve all files in staging area that are added, modified or renamed
# but no deletions etc
FILES=$(git diff-index --name-only --cached --diff-filter=ACMR $against -- )

if [ "$FILES" == "" ]; then
    exit 0
fi

# create temporary copy of staging area
if [ -e $TMP_STAGING ]; then
    rm -rf $TMP_STAGING
fi
mkdir $TMP_STAGING

# match files against whitelist
FILES_TO_CHECK=""
for FILE in $FILES
do
    echo "$FILE" | egrep -q "*.php"
    RETVAL=$?
    if [ "$RETVAL" -eq "0" ]
    then
        FILES_TO_CHECK="$FILES_TO_CHECK $FILE"
    fi
done

if [ "$DEBUG_MODE" -eq "1" ]
    then
    echo "phpcs will run against: [ $FILES_TO_CHECK ]"
fi

if [ "$FILES_TO_CHECK" == "" ]; then
    exit 0
fi

# Copy contents of staged version of files to temporary staging area
# because we only want the staged version that will be commited and not
# the version in the working directory
STAGED_FILES=""
for FILE in $FILES_TO_CHECK
do
  ID=$(git diff-index --cached $against $FILE | cut -d " " -f4)

  # create staged version of file in temporary staging area with the same
  # path as the original file so that the phpcs ignore filters can be applied
  mkdir -p "$TMP_STAGING/$(dirname $FILE)"
  git cat-file blob $ID > "$TMP_STAGING/$FILE"
  STAGED_FILES="$STAGED_FILES $TMP_STAGING/$FILE"
done

OUTPUT=$($PHPCS_BIN -s --standard=$PHPCS_CODING_STANDARD $STAGED_FILES)
RETVAL=$?

# delete temporary copy of staging area
rm -rf $TMP_STAGING

# Allows us to read user input below, assigns stdin to keyboard
exec < /dev/tty

if [ $RETVAL -ne 0 ]; then
    echo "$OUTPUT"
    echo -e "\nPlease fix phpcs errors first\nDo you still want to make this commit? [y|n]"
    read resp
    while true; do
        case $resp in
            [Yy1]* ) exit 0;;
            [Nn0]* ) exit 1;;
			* ) echo "Aborting commit"; exit 1;;
        esac
    done
fi

exit $RETVAL


Git Hook to prompt proper commit message if length is less than 25 

#!/bin/sh

# Author : Mayank Mishra <mayank.mishra@naukri.com>

# To enable this message, add this file into .git/hooks folder in your repository

filename="$1"
msg=""
while read -r line
do
    msg=$msg$line
done < "$filename"

exec < /dev/tty

size=${#msg}
if [ $size -lt 25 ]
then
        echo "\n-----------------GIT--ERROR-------------------";
        echo "Commit Message \"$msg\" is less than 25 characters";
        echo "-----------------------------------------------\n";

	while true;do
		read -p "Edit message (Y) or Abort commit (N) : " input
		if [ "$input" = "" ]; then
    			input='Y'
  		fi
		case $input in 
			[Yy] ) 
				while true;do
					read -p "Enter Commit Message : " msg
					size=${#msg}
					if [ $size -lt 25 ] 
					then
						echo "Commit Message \"$msg\" is still less than 25 characters"
					else 
						echo $msg > $filename
						break
					fi
				done
				break;;
			[Nn] ) 
				echo "Commit Aborted !"
				exit 1
				break;; 
			* ) echo "Please answer Y or N";;
		esac
	done
fi

guidelines

TL;DR

    The highest right(s) a user can obtain is `Developer`
    A user can have not more than 5 project(s) in his local workspace.
    To obtain permission to a repository approval of the respective team manager is required
    We shall follow Forking Workflow in case of Repositories under Group(s) like NaukriLibs, NaukriGulfLibs, FirstNaukriLibs, etc.


Group(s)

    The highest right(s) a user can obtain in any group is `Developer`
    `Owner` rights to a group lies only with TechOps Team
    Any new group would be created only after proper discussion

Repositories / Project(s)

    The highest right(s) a user can obtain in any group is `Developer`
    `Owner` rights to a repository lies only with TechOps Team
    Addition of a user to any of the existing project shall be upon approval by respective project team manager(s)
    Any new repository  / project would be created only after proper discussion

User(s)

    A user can have a maximum of 5 project(s) in his local workspace, for additional projects to be added he must remove earlier one and create a new one.
    Each user must use LDAP / Exchange Credentials to login to Gitlab

Design discussion checklist 

# Design discussion checklist
1. Impact Analysis 
2. Database/tables design
3. Class design
4. Use of factories
5. Decoupling of code
6. Use of DI
7. Code should be UT compatible
8. Performance
9. Caching layer design
10. Memory utilization / optimization
11. Bandwidth usage
12. Queries / service calls
13. Capacity planning
14. Use of proper technologies
15. Services needed / to be built
16. 3rd party / generic libraries that could be built
17. existing 3rd party / generic / already built libraries / classes / functions that could be re-used
18. Impact analysis for deployment

Code Review Checklist 

### Code review can be done when code is = 100% complete
### Code reviews can also happen when code structure is ready for checking adherence to design

# Code review checklist 
1. Adherence to design against a design document(if available)
2. Is the code testable ?
3. UT coverage / availability
4. Readability / understandability / flow of code
5. Configuration management in code
6. Reusability and extensibility of code
7. Graceful degradation
8. Performance of code
9. Number of service / db calls ?
10. how well do recursive functions run?
11. Are objects duplicated when only references are needed and vice versa?
12. Does the code have impact on size, speed or memory usage
13. Are there blocking system/service/db calls?
14. Are required columns indexed in db?
15. What is the memory footprint of code ?
16. Should the operations be synchronous / asynchronous ?
17. API/service timeouts handled in code ?
18. Error handling, logging and alerts/notification
19. Logging of stats if required
20. Security
21. Output escaping is on
22. PDO - Reviewer should verify that PDO (with prepared statements) is being used properly to prevent SQL injection
23. Exec, eval and passthru should be avoided unless absolutely necessary
24. Check for command injection - If you are calling external programs (i.e. exec(), passthru()), then make sure that you escape the arguments.
25. Sanitization of variables
26. CSP headers are in place ?
27. Donâ€™t move uploaded files to web-accessible directories, as your web server may parse some files as executable code (i.e. an uploaded .php file). It also hampers your ability to restrict access to the files (as noted before about hiding files). After the usage, make sure that the file is deleted from the disk.
28. In DbFramework, ncMysqlDatabase should not be used. Use ncPdoDatabase instead.
29. Reviewer should verify that ncUploader is being used for file uploads and file_uploads is off in php.ini
30. Never use user input directly in a pathname, so that problems like directory traversal etc. can be avoided.
31. Authentication should be cookie based; and the auth-id should not be present in the URL.
32. All cookies should be http-only & secured-only.
33. Check to make sure that attackers canâ€™t include a remote file containing PHP code.
34. Reviewer should verify that ncEncryptionLib is being used for encryptions.
35. Reviewer should verify that CSRF library is being used.
36. Pages that conduct long or resource intensive operations should be throttled, so that performing a denial-of-service attack against you isnâ€™t as simple as leaving 10 browser windows on auto-refresh.
37. If you using a page to redirect to other pages (or other sites), make sure that this cannot be abused. i.e. the user is not redirected any non-infoedge website.
38. Donâ€™t put configuration files or any critical files in a web accessible directory, especially if their content can be read via the browser.
39. Make sure that the encryption keys are being changed periodically.
40. Make sure that a user cannot view other users' data. i.e. SQL queries should have USER_ID=? clause wherever possible.
41. Check whether any sensitive information is not being used in hidden values, cookies, local storage, query string, html comments etc.
42. All new services like SP service, memcache, redis etc  listen on back-link only.



# FEP code review points

## HTML
1. Write standards compliant markup
2. SublimeLinter is great for catching errors (HTML, CSS, javascript and a lot of other languages).
3. Make use of semantic elements
4. Use lowercase letters within element names, attributes, and values.
5. Strictly use double quotes, not single or completely omitted quotes.
6. Check to make sure elements used are the right ones, for example don't use two <br/> tags when you should have a <p> tag in there.
7. Separate content from style
8. Inline styles are really for HTML emails and WYSIWYG editors only, and both of those are out of necessity. 
9. Avoid a case of div-itis
10. Look for areas where less code can be used. This is especially a challenge when working with CMS's, but there are always options to cut down on superfluous markup. 

## CSS
1. Organize code with comments
2. This will help the next person who looks at your CSS and for your future self-down the line.
3. Indent selectors
4. Better readability when editing your code. 
5. Write CSS with multi-line spacing
6. Really a preference here, just make sure a consistent pattern is used.
7. Modularize styles for reuse
8. Alphabetize your CSS property for better performance.
9. Use ID and class names that are as short as possible.
10. Use shorthand properties when available
11. TRBL (Top, right, bottom, left). Cuts down on style properties, easier to maintain.

## Images
1. Make use of sprites

## Javascript:
1. Avoid inline and embedded JavaScript.
2. Keep the global scope clean. Put code into Namespaces Page, Util, and Controls.
3. Feature Detect â€“ i.e. before using any advanced feature on an old browser assuming that it may support, letâ€™s first check to see if the function exists, and then use it.
4. Test performance in all browsers mentioned above â€“ use console.time to track down performance bottlenecks.
5. In order to minimize number of event listeners on a page, use event delegation.
6. Keep components as independent as possible.
7. Avoid using global variables. All variables used in a function should be declared as local variables
8. For Code Validation use JSLint . It has tons of features and settings that can be used to customize verification algorithms in to suit our needs.

Note : Code review does not guarantee 100% bug free code.

Semantic Versioning 

Q: What is the tags / versions going to look like?
   
     vX.Y.Z-beta1, vX.Y.Z-beta2....vX.Y.Z-rc1, vX.Y.Z-rc2...,vX.Y.Z

Q: What does X, Y, Z stands for?
   
     X - Major Version (Usually in case of revamp or major functionality additions)
     Y - Minor Version (Regular feature addition(s) - excluding bugfixes / enhancements)
     Z - Bugfixes / Enhancements

Q: When do I decide version for a release?

    The version for a release can be decided at the time of first iteration and it stays fixed till the release.
    The version for a release can also be decided at the time of QA Drop for first iteration and again it stays fixed till the final release

Q: Does `Z` changes with every QA Drop?
    
     No. Since the version is for the software / application / release it stays same through out the cycle. As mentioned above all consecutive QA Drops are suffixed with beta1, beta2, beta3, etc. & Staging / Pre-release drops with rc1, rc2, rc3, etc. respectively

Q: When & Where do I create a stable version for a release i.e. vX.Y.Z?
   
    The final version is created on Master branch upon successfull merge after the release.

Q: What if my release gets postponed and goes live in future?
    
     A new version will be created whenever it goes live keeping the sequence of version intact. It(s) perfectly fine to skip release number(s) between development. For example we can have a release version 1.4.12 going before 1.4.10. But when 1.4.10 becomes ready, it will be re-versioned as 1.4.13 during QA / Pre-releases / Release drop(s).

Please connect with me or Jayant in case of any doubts.

*Please note: The same shall be implemented as hooks in Git restricting any tag which is not in proper format to be pushed to http://gitlab.infoedge.com.

Ref.: http://semver.org/

Git aliases 
1)
    i)  git config --global alias.lg "log --graph --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)â€” %an%C(reset)%C(bold yellow)%d%C(reset)' --abbrev-commit --date=relative --all"
    ii) git lg
    
2) Use rebase instead of merge
    git config --global branch.autosetuprebase always
    
3) Cache uname/password until timeout
    git config --global credential.helper 'cache --timeout=36000'

Git Migration Process 
1. Revoke Write Access to existing Subversion repository**
2. Porting of Code (including svn:externals) to Git (i.e. Latest Stable Code)*
3. Changing of Capistrano to deploy code from Git repository**
4. Setup of development environment to point to Git repository***

* Done using script(s)
** Tasks to be performed by TechOps Team
*** Task to be performed by Development Team



